name: AWS EC2 Self-Hosted Runner

on:
  workflow_dispatch: # Manual trigger only

env:
  AWS_REGION: us-east-1
  INSTANCE_TYPE: t2.micro
  AMI_ID: ami-08982f1c5bf93d976
  RUNNER_LABEL: ephemeral-runner
  RUNNER_NAME: aws-runner

permissions:
  actions: write
  contents: read

jobs:
  launch-runner:
    name: Launch EC2 and Configure Runner
    runs-on: ubuntu-latest
    outputs:
      instance_id: ${{ steps.launch-ec2.outputs.instance_id }}
      public_ip: ${{ steps.launch-ec2.outputs.public_ip }}
      runner_token: ${{ steps.get-token.outputs.runner_token }}

    steps:
      # 1. Configure AWS CLI
      - name: Configure AWS CLI
        run: |
          aws configure set aws_access_key_id ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws configure set aws_secret_access_key ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws configure set aws_session_token ${{ secrets.AWS_SESSION_TOKEN }}
          aws configure set default.region $AWS_REGION

      # 2. Ensure Default VPC Exists
      - name: Ensure Default VPC
        id: ensure-vpc
        run: |
          echo "Checking for default VPC..."
          default_vpc=$(aws ec2 describe-vpcs --filters Name=isDefault,Values=true --query 'Vpcs[0].VpcId' --output text)

          if [ "$default_vpc" == "None" ] || [ -z "$default_vpc" ]; then
            echo "No default VPC found. Creating one..."
            default_vpc=$(aws ec2 create-default-vpc --query 'Vpc.VpcId' --output text)
            echo "Created default VPC: $default_vpc"
          else
            echo "Default VPC exists: $default_vpc"
          fi

          echo "vpc_id=$default_vpc" >> $GITHUB_OUTPUT

      # 3. Ensure Default Security Group Exists and Open SSH
      - name: Ensure Security Group
        id: ensure-sg
        run: |
          vpc_id=${{ steps.ensure-vpc.outputs.vpc_id }}

          echo "Checking for default security group in VPC $vpc_id..."
          default_sg=$(aws ec2 describe-security-groups \
            --filters Name=vpc-id,Values=$vpc_id Name=group-name,Values=default \
            --query 'SecurityGroups[0].GroupId' --output text)

          if [ "$default_sg" == "None" ] || [ -z "$default_sg" ]; then
            echo "Default security group missing, creating one..."
            default_sg=$(aws ec2 create-security-group \
              --group-name default \
              --description "Default SG for GH Runner" \
              --vpc-id $vpc_id \
              --query 'GroupId' --output text)
          else
            echo "Default security group exists: $default_sg"
          fi

          echo "Authorizing SSH inbound rule (22)..."
          aws ec2 authorize-security-group-ingress \
            --group-id $default_sg \
            --protocol tcp --port 22 --cidr 0.0.0.0/0 || echo "Rule already exists"

          echo "sg_id=$default_sg" >> $GITHUB_OUTPUT

      # 4. Get GitHub Runner Registration Token
      - name: Get GitHub Runner Registration Token
        id: get-token
        run: |
          token=$(curl -sX POST -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            https://api.github.com/repos/${{ github.repository }}/actions/runners/registration-token \
            | jq -r .token)
          echo "runner_token=$token" >> $GITHUB_OUTPUT

      # 5. Launch EC2 Instance
      - name: Launch EC2 Instance
        id: launch-ec2
        run: |
          vpc_id=${{ steps.ensure-vpc.outputs.vpc_id }}
          sg_id=${{ steps.ensure-sg.outputs.sg_id }}

          echo "Finding a subnet in default VPC $vpc_id..."
          subnet_id=$(aws ec2 describe-subnets --filters Name=vpc-id,Values=$vpc_id --query 'Subnets[0].SubnetId' --output text)

          if [ "$subnet_id" == "None" ] || [ -z "$subnet_id" ]; then
            echo "No subnet found in default VPC. Cannot continue."
            exit 1
          fi

          echo "Launching EC2 instance in subnet $subnet_id..."
          instance_id=$(aws ec2 run-instances \
            --image-id $AMI_ID \
            --instance-type $INSTANCE_TYPE \
            --iam-instance-profile Name=EC2RunnerRole \
            --subnet-id $subnet_id \
            --security-group-ids $sg_id \
            --associate-public-ip-address \
            --tag-specifications 'ResourceType=instance,Tags=[{Key=Name,Value=GH-Runner}]' \
            --query 'Instances[0].InstanceId' --output text)

          echo "Waiting for instance to be running..."
          aws ec2 wait instance-running --instance-ids $instance_id

          public_ip=$(aws ec2 describe-instances \
            --instance-ids $instance_id \
            --query 'Reservations[0].Instances[0].PublicIpAddress' --output text)

          echo "instance_id=$instance_id" >> $GITHUB_OUTPUT
          echo "public_ip=$public_ip" >> $GITHUB_OUTPUT

          echo "Launched instance $instance_id with public IP $public_ip"

      # 6. Install GitHub Actions Runner
      - name: Install GitHub Runner on EC2 via SSM
        run: |
          instance_id=${{ steps.launch-ec2.outputs.instance_id }}
          echo "Waiting for EC2 instance $instance_id to register with SSM..."
          
          # Wait for SSM registration
          for i in {1..30}; do
            if aws ssm describe-instance-information --filters "Key=InstanceIds,Values=$instance_id" --query 'InstanceInformationList[0].PingStatus' --output text 2>/dev/null | grep -q "Online"; then
              echo "Instance registered with SSM"
              break
            fi
            echo "Waiting for SSM registration... ($i/30)"
            sleep 10
          done
          
          echo "Installing GitHub runner using SSM..."
          COMMAND_ID=$(aws ssm send-command \
            --targets "Key=instanceIds,Values=$instance_id" \
            --document-name "AWS-RunShellScript" \
            --comment "Install GitHub Actions Runner" \
            --parameters 'commands=[
              "mkdir actions-runner && cd actions-runner",
              "curl -o actions-runner-linux-x64-2.313.0.tar.gz -L https://github.com/actions/runner/releases/download/v2.313.0/actions-runner-linux-x64-2.313.0.tar.gz",
              "tar xzf ./actions-runner-linux-x64-2.313.0.tar.gz",
              "sudo dnf makecache --refresh",
              "sudo dnf -y install lld",
              "sudo yum install libicu -y",
              "./config.sh --url https://github.com/${{ github.repository }} --token ${{ steps.get-token.outputs.runner_token }} --name runner-$(hostname)-$(date +%s) --labels self-hosted,linux,x64 --unattended",
              "./svc.sh install $USER",
              "sudo ./svc.sh start",
              "echo Runner installation completed successfully"
            ]' \
            --query 'Command.CommandId' --output text)
          
          echo "Command ID: $COMMAND_ID"
          echo "Waiting for command completion..."
          
          # Wait for command to complete
          for i in {1..30}; do
            STATUS=$(aws ssm get-command-invocation --command-id "$COMMAND_ID" --instance-id "$instance_id" --query 'Status' --output text 2>/dev/null)
            if [ "$STATUS" = "Success" ]; then
              echo "Runner installation completed successfully"
              break
            elif [ "$STATUS" = "Failed" ]; then
              echo "Runner installation failed"
              aws ssm get-command-invocation --command-id "$COMMAND_ID" --instance-id "$instance_id" --query 'StandardErrorContent' --output text
              exit 1
            fi
            echo "Command status: $STATUS ($i/30)"
            sleep 10
          done